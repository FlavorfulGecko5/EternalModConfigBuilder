To best understand what is happening here, you should have "config.txt" open and readable alongside this file.
To read all the syntax rules for options and names, see "Constants.cs"

Let's start simple: the following label has a constant "999" as it's expression.
This means the label will be replaced with "999" when this file is parsed.
$emb_var#999$

To insert an option we defined in our configuration file into the expression,
we encase the option's name in braces {}. The following label would be replaced
with the value of the option "x", which is defined in the configuration file.
$emb_var#{x}$

Of course, our expressions can be more complicated than just single values.
We can have a full range of arithmetic expressions - as the following two 
examples show. Note that both "x" and "y" are defined in our configuration file.
$emb_var#{x} + {y}$
$emb_var#(10 + {x}) / 5 * 2$





What if the values we want to insert are strings? Wherever this is the case,
we must put single quotes ('') around string literals or variables representing strings
$emb_var#'The Revenant'$
$emb_var#'{name}'$

Using these rules, we can concatenate (combine) two strings together like so:
$emb_var#'{name}' + ' is the best demon'$





We can also perform a rule range of logical expressions:
$emb_var#true AND false$
$emb_var#{binary} OR false$
$emb_var#NOT {binary}$





Variables can be used to represent other variables. The following label will
be replaced with the value of "y":
$emb_var#{z}$





This segment demonstrates how 'Text' variables are output:
$emb_var#'{largeText}'$
As you can see, each element of the list is output onto it's own line





This segment shows how to access variables created by 'Map' Options
$emb_var#{mapObject[first]}$
$emb_var#{mapObject[second]}$
$emb_var#'{mapObject[3]}'$

Simply inputting the name of the Map Option with no key will yield
the number of entries inside the Map.

This Map Option has $emb_var#{mapObject}$ entries.





Next-up, we have toggle labels. Whereas a variable label will be replaced with whatever
it's expression evaluates to, a toggle label can be used to keep or remove an entire
section of a file, based on what it's expression evaluates to. Toggle label expressions
MUST evaluate to a Boolean (true/false), or a numerical value.
$emb_toggle#true$
I will still be visible when this file is parsed.
$emb_toggle_end#$

$emb_toggle#{x} = 0$
I will not be visible when this file is parsed.
$emb_toggle_end#$

Toggle labels can be nested inside of each other
$emb_toggle#1$
I will be visible when this file is parsed.

$emb_toggle#0.85$
However, I will not be visible! (Any number < 1 is considered false for a toggle label)
$emb_toggle_end#$

$emb_toggle_end#$





Expressions are evaluated by first substituting variables, then computing the result.
However, you may run into situations where you need to fully evaluate parts of an expression
before variables are substituted into the rest of it. In these instances, you can define a
subexpression block using the format: {!SUB}[Expression]{!SUBEND}
$emb_var# {!sub}2 + 3{!subend} * {!sub}2{!subend} $

$emb_toggle# {!sub}true{!subend} $
I will be visible thanks to subexpressions!
$emb_toggle_end#$





Starting in Beta 1.5.0, you may define and use list variables in your configuration files.
The elements of a list are accessed by their index, starting at index 0
The first element in 'listA' is $emb_var#{listA[0]}$

The name of the list, without any index notation, represents the number of elements inside the list:
$emb_var#'listA contains {listA} elements'$

To access the last element in the list, using the number of elements, you could do something like:
The last element in 'listA' is $emb_var#{listA[{!sub}{listA} - 1{!subend}]}$

This last expression also shows a practical application of the subexpression system discussed above.





Beta 1.8.0 has introduced the Loop Label. This allows you to iterate over a set of integers and evaluate an expression multiple times.

A simple example: $emb_loop# 1 & 3 & 'hello ' $
> This label will be replaced with the world "hello" written three times.
> Here, 1 is the initial loop value, 3 is the final value, and 'hello' is the expression that will be evaluated multiple times. 
> These three elements are separated by the character '&'

We can retrieve the loop value using the '{!inc}' symbol. The following loop label will output all loop values, one per iteration:
$emb_loop# -3 & 5 & {!inc} + ' '$

This label can be very powerful when combined with lists. For instance:
$emb_loop# 0 & {listA} - 1 & '{listA[{!inc}]}
'$

This loop will output all elements of the listA variable - one element per line.





There are many other features you can include in these expressions. To get a better idea of what
operators and functions are available, consult the following documentation:
https://docs.microsoft.com/en-us/dotnet/api/system.data.datacolumn.expression?redirectedfrom=MSDN&view=net-6.0#System_Data_DataColumn_Expression